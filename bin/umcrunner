#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# umcrunnerd - umcrunner client
# 09-2018, Tomas Vitvar, tomas@vitvar.com

import os
import sys
import requests
import requests
import yaml
import datetime
import socket
import time
import argparse
import re
import json
import select
import utils

import messages as Msg

from time import sleep
from datetime import datetime, timedelta
from json2table import Table

# local libraries
import libs.messages as Msg
from libs.umcconfig import UmcConfig

# global variables
args=None
server_list=None
connect_str=None

# formatting functions
def format_state(cdef, value, entry):
    return "1" if value is True else "0"    

def format_time(cdef, value, entry):
    return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(float(value)))    

def format_float(cdef, value, entry):
    return "%.2f"%value

def format_uptime(cdef, value, entry):
    sec = timedelta(seconds=int(value))
    d = datetime(1,1,1) + sec
    return "%.2d:%.2d:%.2d:%.2d" % (d.day-1, d.hour, d.minute, d.second)    
    
def format_runs(cdef, value, entry):
    return "%s/%s"%(entry["num_runs"],entry["num_errors"])

def format_returncode(cdef, value, entry):
    return value[0][1] if len(value)>0 else "-"

stats_umc = [
    { "name" : "HOST/ID",     "mlen" : 0,  "value" : "{hostname}/{umc_instanceid}",                         "help" : "umc instance ID" }, 
    { "name" : "STT",         "mlen" : 0,  "value" : "{enabled}",            "format" : format_state,       "help" : "Current state, 1=enabled, 0=disabled"}, 
    { "name" : "ROT-DEL-CNT", "mlen" : 0,  "value" : "{rotation_timelimit}-{delay}-{count}",                "help" : "Log rotation time/delay/count." }, 
    { "name" : "RNS/ERS",     "mlen" : 0,  "value" : "{num_runs}/{num_errors}",                             "help" : "Number of total iterations and failed iterations." }, 
    { "name" : "STARTED",     "mlen" : 0,  "value" : "{last_started_time}",  "format" : format_time,        "help" : "Last time umc instance was started." },
    { "name" : "P_TPID",      "mlen" : 0,  "value" : "{stats.p.top_pid}",                                   "help" : "umc instance top PID." }, 
    { "name" : "P_CHP",       "mlen" : 0,  "value" : "{stats.p.num_chproc}",                                "help" : "Number of children processes." }, 
    { "name" : "P_RSS",       "mlen" : 0,  "value" : "{stats.p.rss}",        "format" : format_float,       "help" : "Total amount of memory in MBs umc instance currently takes." }, 
    { "name" : "P_CPU",       "mlen" : 0,  "value" : "{stats.p.cpu}",        "format" : format_float,       "help" : "Total CPU time umc instance took from its last start." }, 
    { "name" : "P_UPT",       "mlen" : 0,  "value" : "{stats.p.uptime}",     "format" : format_uptime,      "help" : "The time the current umc instance is running." },
    { "name" : "LRC",         "mlen" : 0,  "value" : "{returncodes}",        "format" : format_returncode , "help" : "Last return code." },
    { "name" : "LAST_ERROR",  "mlen" : 0,  "value" : "{lasterror_time}",     "format" : format_time ,       "help" : "Last time an error occurred." }
]

# resource definitions
resources = {
    "umc" : { "url" : "/stats/hosts/{hostname}/umc", "table_def" : stats_umc, 
        "help" : "umc instances configuration and runtime information" } 
}

# commands definitions
commands = {
    "terminate" : { 
        "url" : "/terminate/hosts/{hostname}/umc/{terminate}", "confirm" : True, 
        "q" : "This will terminate umc instances '{terminate}' on {hostname} host(s)!", 
        "help" : "terminate umc instance" }
}

# send request
def send_request(method, url):
    global connect_str
    if connect_str is None:
        # prefer connect on the command line
        if args.connect is not None:
            connect_str=args.connect 
        
        # get connect from the configuration
        if server_list is not None:
            for hostname,sdef in server_list.items():
                if sdef.me:
                    connect_str="%s:%s"%(sdef.address,sdef.tcp_port)
                    sdef.discarded=True
                    break
        
        # fallback to the local connect
        if connect_str is None:
            connect_str="%s:%s"%(socket.gethostname(),1989)
    
    while True:
        try:
            furl='http://%s%s'%(connect_str, url)    
            if method=="get":
                return requests.get(furl, timeout=(args.connect_timeout, args.read_timeout))
            elif method=="post":
                return requests.post(furl, timeout=(args.connect_timeout, args.read_timeout))
            else: raise Exception("Fatal: the method %s is not supported!"%method)
        except requests.exceptions.ConnectionError as e:
            old_connect_str=connect_str
            connect_str=None
            if server_list is not None:
                for hostname,sdef in server_list.items():
                    if sdef.discarded is None:
                        connect_str="%s:%s"%(sdef.address,sdef.tcp_port)
                        sdef.discarded=True
                        break
            if connect_str is None:
                connect_str=old_connect_str
                raise e 
        # except
    # while
# send_request

# *** MAIN
if __name__ == "__main__":    

    # arguments
    parser = argparse.ArgumentParser(description='umcrunner client', add_help=False)
    conopts = parser.add_argument_group('optional connection arguments')    
    conopts.add_argument('--connect', required=False, default=None, help='umcrunner daemon host nad port to connect',metavar="<host:port>")
    conopts.add_argument('--connect-timeout', required=False, default=0.5, help='HTTP connection timeout, default=0.5s',metavar="<timeout>")
    conopts.add_argument('--read-timeout', required=False, default=10, help='HTTP read timeout, default=10s',metavar="<timeout>")
    
    group=parser.add_argument_group("stats and commands")
    statcom = group.add_mutually_exclusive_group(required=True)    
    statcom.add_argument('--stats', required=False, metavar="hosts|umc", dest='resource',const='hosts',action='store',nargs='?',type=str,
        help='resource stats to retrieve, default="hosts"')    
    statcom.add_argument('--terminate', metavar="<umc>", required=False, default=None, action='store',help='terminate umc instance')
    
    prmopts = parser.add_argument_group('parameters for stats and commands')    
    prmopts.add_argument('--hostname', required=False, metavar="<name>", default='all',action='store',type=str,
        help='run request on a host, default="all"')
    
    fmtopts = parser.add_argument_group('output format and display arguments')    
    fmtopts.add_argument('--format', required=False, metavar="<text|json>", default="text", help='output format, default=text', action='store', type=str) 
    fmtopts.add_argument('--noterm', required=False, help='do not detect terminal dimensions',action='store_true')    
    fmtopts.add_argument('--cont', required=False, default=False, action='store_true',help='display stats continuosly')
    fmtopts.add_argument('--refresh', required=False, metavar="<interval>", default=5, action='store',type=int,help='refresh interval for continuous display of stats')
    
    otopts = parser.add_argument_group('optional other arguments')
    otopts.add_argument("-h", "--help", action="help", help="show this help message and exit")
    otopts.add_argument('--describe', required=False, help='describe resource structure',action='store_true')     
    otopts.add_argument('--yes', required=False, default=False, help='answer all questions as \'yes\'',action='store_true')    
    otopts.add_argument('--verbose', required=False, help='be verbose',action='store_true')
    args=parser.parse_args()
    Msg.verbose = args.verbose

    try:
        # configuration file
        configFile=os.environ.get('UMCRUNNER_CONFIG', None)        
        if configFile is not None:
            server_list = UmcConfig(configFile).get_server_list()

        command_def=None
        for cmd,cmd_def in commands.items():
            if vars(args).get(cmd) is not None:
                command_def = cmd_def
                break
        
        if command_def is not None:
            if not(command_def["confirm"]) or args.yes or utils.query_yes_no(utils.unpack(vars(args),command_def["q"]) + " Are you sure?"):
                response=send_request("post", utils.unpack(vars(args),command_def["url"]))
                m = response.json()
                if args.format=="text":                    
                    for x in m:
                        if x.get("msg") is not None:
                            sys.stdout.write("- %s\n"%x["msg"])
                        else:
                            sys.stderr.write("Unknown message format!\n")
                else:                        
                    sys.stdout.write("%s\n"%json.dumps(response.json(), indent=2))
            
            sys.exit(0)            
        # command
        
        # print statistics for chosen resource
        rdef = resources.get(args.resource)
        if rdef is not None:
            table = Table(rdef["table_def"])
            if args.describe:
                sys.stdout.write("%s (URL=%s).\n\n"%(rdef["help"],rdef["url"]))
                table.describe(args.noterm)
            else:
                while True:
                    response=send_request("get", utils.unpack(vars(args),rdef["url"]))
                    response.raise_for_status()
                    
                    if args.cont and args.format=="text": os.system('clear')

                    if args.format=="text":                    
                        table.display(response.json(), args.noterm)
                    else:                        
                        sys.stdout.write("%s\n"%json.dumps(response.json(), indent=2))
                        
                    if args.cont and args.format=="text":
                        sleep(args.refresh)
                    else:
                        break;
                # while                    
        else:
            raise Exception("Unknown resource: %s"%args.resource)
        
        print ""
    except KeyboardInterrupt as e:
        print ""
        pass
    except requests.exceptions.ReadTimeout as e:
        sys.stderr.write("Read timeout occured when sending the request")        
    except requests.exceptions.ConnectTimeout as e:
        sys.stderr.write("Connect timeout occured when sending the request")        
    except requests.exceptions.ConnectionError as e:
        sys.stderr.write("Unable to connect: %s\n"%connect_str)        
    except Exception as e:
        sys.stderr.write("%s\n\n"%str(e))
        

    
